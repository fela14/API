Secure Key Permissions
chmod 400 flask-key-pair.pem
‚Üí Restrict access to your private key file for SSH.

SSH into EC2
ssh -i "flask-key-pair.pem" ubuntu@16.171.165.135
‚Üí Connect to your EC2 instance using your private key.

Update and Upgrade Packages
sudo apt update && sudo apt -y upgrade
‚Üí Refresh and upgrade all system packages.

Set Hostname
sudo hostnamectl set-hostname flask-server
‚Üí Change the server name for easy identification.

Check Hostname
hostname
‚Üí Verify the current system hostname.

Edit Hosts File
sudo nano /etc/hosts
‚Üí Open the system hosts file in the nano editor.
  You can map hostnames to IP addresses here, e.g.:
  127.0.0.1   localhost
  13.60.231.180   flask-server
  This helps ensure your new hostname resolves locally.

Switch to Root (temporary)
sudo -i
‚Üí Switch to the root user for full administrative access.
  Use 'exit' to return to the ubuntu user.

Allow Sudo Without Password
sudo visudo
‚Üí Opens the sudoers file.
  Add this line at the end to skip password prompts:
  ubuntu ALL=(ALL) NOPASSWD: ALL

Add Ubuntu User to Sudo Group
sudo adduser ubuntu sudo
‚Üí Ensures the 'ubuntu' user has sudo privileges.
  (Output: The user 'ubuntu' is already a member of 'sudo'.)

Create SSH Directory
mkdir .ssh
‚Üí Creates the .ssh directory in the home folder if it does not already exist.
‚Üí Required for storing authorized SSH keys securely.

====================================================

Generate SSH Key Pair on Local Machine
ssh-keygen -b 4096
‚Üí Creates a new ED25519 SSH key pair on the host system for secure authentication.

Copy Public Key to Server
scp -i flask-key-pair.pem ~/.ssh/id_ed25519.pub ubuntu@16.171.165.135:~/.ssh/authorized_keys
‚Üí Securely copies the local public key to the EC2 instance using the .pem key for authentication.
‚Üí Transfer successful.

=====================================================

Set Permissions for SSH Directory and Keys
sudo chmod 700 ~/.ssh
‚Üí Ensures only the owner can access the .ssh directory.

sudo chmod 600 ~/.ssh/*
‚Üí Restricts access to SSH key files so only the owner can read/write them.
‚Üí Prevents SSH from rejecting keys due to insecure permissions.

Now I Can Login from My Local Host Without a Password
‚Üí Verifies that SSH key-based authentication is working properly.
  Example: ssh ubuntu@16.171.165.135

=====================================================

Edit SSH Daemon Configuration
sudo nano /etc/ssh/sshd_config
‚Üí Opens the SSH configuration file for editing.

Inside the file, locate and modify (or add) the following lines:

PasswordAuthentication no
‚Üí Disables password-based SSH login.
  This ensures only key-based authentication is allowed ‚Äî much more secure.

PermitRootLogin no
‚Üí Prevents direct root login over SSH.
  This forces all users to log in as a normal user (e.g., ubuntu) and use sudo for administrative tasks.

Save and exit (Ctrl + O, Enter, Ctrl + X).

Restart SSH Service
sudo systemctl restart ssh
‚Üí Applies the new SSH configuration changes immediately.

Install UFW
sudo apt install ufw
‚Üí Installs the Uncomplicated Firewall (UFW) package for managing firewall rules.

Set Default Policies
sudo ufw default deny incoming
‚Üí Denies all incoming connections by default (safer baseline).

sudo ufw default allow outgoing
‚Üí (Optional but recommended) Allows all outgoing connections from the server.

Allow SSH Access
sudo ufw allow ssh
‚Üí Allows SSH connections (port 22) so you don‚Äôt get locked out after enabling the firewall.

Allow Flask App Port
sudo ufw allow 5000
‚Üí Opens port 5000 for your Flask application (temporary for testing; later you‚Äôll use port 80 or 443 via Nginx).

Enable the Firewall
sudo ufw enable
‚Üí Activates the firewall and ensures it starts automatically on system boot.

Check Firewall Status
sudo ufw status
‚Üí Displays all active firewall rules.

Transfer Flask Project to Server
scp -r ~/API/Flask/corey/blog ubuntu@16.171.165.135:~/
‚Üí Copies your local blog project directory to the EC2 server.

Install Python Package Manager (pip)
sudo apt install python3-pip -y
‚Üí Installs pip3, the Python package manager, so you can install dependencies globally or within a virtual environment.

Install Virtual Environment Module
sudo apt install python3-venv -y
‚Üí Installs Python‚Äôs built-in venv module, allowing you to create isolated environments for your Flask app if needed.
(Useful for keeping project dependencies separate.)

Create Virtual Environment
python3 -m venv blog/venv
‚Üí Creates an isolated environment for project dependencies inside the blog directory.
cd blog/
source venv/bin/activate
‚Üí Moves into your Flask project directory.
‚Üí Activates the virtual environment.

Install Dependencies
pip install -r requirements.txt
‚Üí Installs all required Python packages for your Flask project inside the virtual environment.

Create Config JSON
sudo touch e
sudo chmod 600 /etc/config.json
‚Üí Creates an empty configuration file with secure permissions.

Secure Config File for Secrets
sudo touch /etc/config.json
sudo chmod 600 /etc/config.json
sudo chown ubuntu:ubuntu /etc/config.json

Edit Config JSON
sudo nano /etc/config.json
‚Üí Add environment variables for Flask app

Configure Flask to Use JSON Config
Edit config.py
‚Üí Your Flask app can now use SECRET_KEY, SQLALCHEMY_DATABASE_URI, EMAIL_USER, and EMAIL_PASS directly from this file (config.get instead of os.environ.get).

üöÄ Run Flask App
export FLASK_APP=run.py
flask run --host=0.0.0.0
‚Üí Starts the Flask app on all network interfaces (port 5000 by default).
Visit: http://<EC2-public-IP>:5000
Stop the app:
Ctrl + C

üß≠ Production Deployment (Nginx + Gunicorn)
Install Nginx
sudo apt install nginx
‚Üí Installs Nginx web server.
‚Üí Verify installation:
sudo systemctl status nginx
Allow through firewall:
sudo ufw allow 'Nginx Full'
sudo ufw status
Install Gunicorn (inside venv)
pip install gunicorn
gunicorn --version
‚Üí Installs Gunicorn WSGI server to serve Flask apps.

üåê Nginx Reverse Proxy Configuration (Manual Setup)
Remove Default Nginx Site
sudo rm /etc/nginx/sites-enabled/default
‚Üí Removes the default Nginx configuration to prevent conflicts.
Create New Blog Configuration
sudo nano /etc/nginx/sites-enabled/blog
Paste this configuration:
server {
    listen 80;
    server_name 13.60.231.180;

    location /static {
        alias /home/ubuntu/Hale_Blog/blog/static;
    }

    location / {
        proxy_pass http://localhost:8000;
        include /etc/nginx/proxy_params;
        proxy_redirect off;
    }
}
‚Üí This routes all HTTP traffic on port 80 to Gunicorn running on port 8000, and serves static files directly from your Flask app‚Äôs static folder.

üîí Firewall Configuration for Production (Switch from Flask to Nginx)
sudo ufw allow http/tcp
‚Üí Opens port 80 (HTTP) to allow web traffic through Nginx.
sudo ufw delete allow 5000
‚Üí Removes access to port 5000, which was only used for Flask‚Äôs development server.
‚Üí Keeps your setup more secure and production-ready.

üîê Finalize Firewall & Nginx Setup
sudo ufw enable
‚Üí Activates the firewall and ensures it auto-starts on boot.
‚ö†Ô∏è You‚Äôll see a warning that it may disrupt SSH connections ‚Äî typing y confirms and applies your firewall rules.
sudo systemctl restart nginx
‚Üí Restarts the Nginx service to apply your new reverse proxy configuration.

üß© Gunicorn Configuration and Performance Tuning
Run Flask App with Gunicorn
gunicorn -w 5 -b 127.0.0.1:8000 run:app
‚Üí Launches the Flask app using Gunicorn with:
5 workers ‚Üí calculated as (2 √ó CPU cores) + 1 for 2 cores.
127.0.0.1:8000 ‚Üí binds Gunicorn to localhost on port 8000 (proxied by Nginx).

=======================================================
üß© Fix Nginx ‚Äú403 Forbidden‚Äù for Static Files (Profile Pictures Not Loading)
Problem:
After deploying Flask with Gunicorn and Nginx, profile images and other static files were not loading.
Nginx returned:

HTTP/1.1 403 Forbidden

Cause:
Nginx runs as the www-data user and didn‚Äôt have permission to traverse your project directories
(/home/ubuntu/Hale_Blog/...).

üõ† Step-by-Step Fix

1Ô∏è‚É£ Check Directory Permissions
Run these one by one to inspect access along the directory chain:

ls -ld /home
ls -ld /home/ubuntu
ls -ld /home/ubuntu/Hale_Blog
ls -ld /home/ubuntu/Hale_Blog/blog
ls -ld /home/ubuntu/Hale_Blog/blog/static
ls -ld /home/ubuntu/Hale_Blog/blog/static/profile_pics

If any of these show permissions like:

drwx------  ubuntu ubuntu ...

then Nginx can‚Äôt enter that directory.

2Ô∏è‚É£ Allow Directory Traversal
Grant safe ‚Äúexecute‚Äù (traverse) permission for others (o+x) on each path:

sudo chmod o+x /home /home/ubuntu /home/ubuntu/Hale_Blog /home/ubuntu/Hale_Blog/blog /home/ubuntu/Hale_Blog/blog/static /home/ubuntu/Hale_Blog/blog/static/profile_pics

This does not allow others to read or modify files ‚Äî it only lets Nginx walk into those directories.

3Ô∏è‚É£ Restart Nginx

sudo systemctl restart nginx

4Ô∏è‚É£ Test Access

curl -I http://127.0.0.1/static/profile_pics/default.jpg

‚úÖ Expected output:

HTTP/1.1 200 OK
Content-Type: image/jpeg

You can also verify externally:

http://13.60.231.180/static/profile_pics/default.jpg
=========================================================

‚öôÔ∏è Set Up Supervisor for Flask App

Purpose:
Supervisor ensures your Flask app (via Gunicorn) automatically starts on boot, restarts on crash, and runs in the background as a managed service.

üß© 1Ô∏è‚É£ Install Supervisor
sudo apt install supervisor -y


‚Üí Installs the Supervisor process control system.

üß© 2Ô∏è‚É£ Create Log Directory
sudo mkdir -p /var/log/blog
sudo chown ubuntu:ubuntu /var/log/blog


‚Üí Creates a dedicated log folder for your Flask app‚Äôs logs.

üß© 3Ô∏è‚É£ Create Supervisor Configuration File

Open the config:

sudo nano /etc/supervisor/conf.d/blog.conf


Paste the following clean, corrected configuration:

[program:blog]
directory=/home/ubuntu/Hale_Blog
command=/home/ubuntu/Hale_Blog/blog/venv/bin/gunicorn -w 5 -b 127.0.0.1:8000 run:app
user=ubuntu
autostart=true
autorestart=true
startasgroup=true
killasgroup=true
stderr_logfile=/var/log/blog/blog.err.log
stdout_logfile=/var/log/blog/blog.out.log


‚úÖ Fixes included:

Corrected the path to match your project (Hale_Blog, not flask_Blog).

Added binding to 127.0.0.1:8000 so Nginx can reverse-proxy correctly.

Fixed user=ubuntu\autostart=true typo ‚Üí separated into two lines.

Corrected missing / in stdout_logfile path.

Ensured logs go to /var/log/blog/.

üß© 4Ô∏è‚É£ Reload and Update Supervisor
sudo supervisorctl reread
sudo supervisorctl update


‚Üí Loads the new program definition.

üß© 5Ô∏è‚É£ Start Your Flask App Under Supervisor
sudo supervisorctl start blog

üß© 6Ô∏è‚É£ Check Status
sudo supervisorctl status


Expected:

blog                            RUNNING   pid 1234, uptime 0:02:15

üß© 7Ô∏è‚É£ View Logs (if needed)
cat /var/log/blog/blog.out.log
cat /var/log/blog/blog.err.log

====================================================
üß© Fix ‚ÄúRequest Entity Too Large‚Äù (File Upload Limit in Nginx)
Problem:
When uploading profile images or other files, you might see:
413 Request Entity Too Large
This means Nginx is blocking uploads that exceed the default limit (1 MB).
Solution:
1Ô∏è‚É£ Edit the main Nginx configuration
sudo nano /etc/nginx/nginx.conf
2Ô∏è‚É£ Add this line inside the http { ... } block (not outside it):
http {
    client_max_body_size 5M;
    ...
}
You can increase the limit (e.g., 10M, 20M) depending on your app‚Äôs needs.
3Ô∏è‚É£ Test Nginx configuration
sudo nginx -t
‚úÖ You should see:
nginx: configuration file /etc/nginx/nginx.conf test is successful
4Ô∏è‚É£ Restart Nginx to apply changes
sudo systemctl restart nginx
========================================================

üîí Certbot / SSL Setup for Nginx
sudo apt-get update
sudo apt-get install software-properties-common
sudo add-apt-repository universe
sudo add-apt-repository ppa:certbot/certbot
sudo apt-get update

# Install the Certbot Nginx plugin
sudo apt-get install -y python3-certbot-nginx

# Edit your Nginx blog config to use your domain
sudo nano /etc/nginx/sites-enabled/blog
# Change:
# server_name 13.60.231.180;
# to:
# server_name www.<mywebsite>.com;

# Test Nginx config
sudo nginx -t
sudo systemctl restart nginx

# Run Certbot to automatically issue and configure SSL
sudo certbot --nginx

# Open HTTPS port in firewall
sudo ufw allow https

# Restart Nginx to apply changes
sudo systemctl restart nginx

# Test auto-renewal (dry run)
sudo certbot renew --dry-run

üîÅ Auto-Renew SSL Certificates (Certbot)

Certbot certificates are valid for 90 days.
Set up a cron job to renew automatically:

sudo crontab -e
# Choose 1 for nano editor
# Add the following line to run renewal at 4:30 AM on the first of every month:
30 4 1 * * sudo certbot renew --quiet